use anyhow::Result;
use glob::Pattern;
use regex::Regex;
use std::fs;
use std::path::Path;

use crate::file_types::{CommentStyle, get_comment_style};

const LICENSE_TEMPLATE: &str = include_str!("../license.txt");

pub struct LicenseChecker {
	ignore_patterns: Vec<Pattern>,
	license_keywords: Regex,
	generated_file_patterns: Vec<Regex>,
}

impl LicenseChecker {
	pub fn new(ignore_patterns: Vec<&str>, verbose: bool) -> Self {
		let mut compiled_patterns = Vec::new();
		for pattern in ignore_patterns {
			if let Ok(compiled) = Pattern::new(pattern) {
				compiled_patterns.push(compiled);
			} else if verbose {
				eprintln!("Warning: Invalid ignore pattern: {}", pattern);
			}
		}

		let license_keywords = Regex::new(r"(?i)(copyright|mozilla public|spdx-license-identifier)")
			.expect("Failed to compile license keywords regex");

		let generated_file_patterns = vec![
			Regex::new(r"(?m)^.{1,2} Code generated .* DO NOT EDIT\.$").unwrap(),
			Regex::new(r"(?m)^DO NOT EDIT! Replaced on runs of cargo-raze$").unwrap(),
			Regex::new(r"(?i)^# autogenerated").unwrap(),
			Regex::new(r"(?i)^// autogenerated").unwrap(),
			Regex::new(r"(?i)generated automatically").unwrap(),
		];

		Self {
			ignore_patterns: compiled_patterns,
			license_keywords,
			generated_file_patterns,
		}
	}

	pub fn should_skip(&self, path: &Path) -> bool {
		let path_str = path.to_string_lossy();

		// Skip common patterns that shouldn't have license headers
		if path_str.contains("/.git/")
			|| path_str.contains("/node_modules/")
			|| path_str.contains("/target/")
			|| path_str.contains("/build/")
			|| path_str.contains("/dist/")
			|| path_str.contains("/.next/")
			|| path_str.contains("/.svelte-kit/")
			|| path_str.contains("/third_party/")
			|| path_str.starts_with("third_party/")
			|| path_str.contains("/secrets/")
			|| path_str.starts_with("secrets/")
			|| path_str.ends_with(".lock")
			|| path_str.ends_with(".log")
			|| path_str.ends_with(".tmp")
		{
			return true;
		}

		// Skip specific files that shouldn't have license headers
		let filename = path.file_name().and_then(|f| f.to_str()).unwrap_or("");
		if filename.eq_ignore_ascii_case("CLAUDE.md")
			|| filename.eq_ignore_ascii_case("AGENTS.md")
			|| filename.eq_ignore_ascii_case("AGENT.md")
			|| filename.eq_ignore_ascii_case("dprint.json")
			|| filename.eq_ignore_ascii_case("renovate.json")
		{
			return true;
		}

		// Check against user-provided ignore patterns
		for pattern in &self.ignore_patterns {
			if pattern.matches(&path_str) {
				return true;
			}
		}

		// Skip files without a recognizable comment style
		get_comment_style(path).is_none()
	}

	pub fn has_license(&self, path: &Path) -> Result<bool> {
		let content = fs::read_to_string(path)?;

		// Check if the file is generated (generated files don't need license headers)
		if self.is_generated_file(&content) {
			return Ok(true);
		}

		// Special handling for JSON files - look for $license property
		if path
			.extension()
			.and_then(|e| e.to_str())
			.map(|e| e.to_lowercase())
			== Some("json".to_string())
			|| path
				.extension()
				.and_then(|e| e.to_str())
				.map(|e| e.to_lowercase())
				== Some("jsonc".to_string())
		{
			return Ok(content.contains("\"$license\":"));
		}

		// Look for license keywords in the first 1000 characters, respecting char
		// boundaries
		let search_content = if content.len() > 1000 {
			// Find a safe char boundary at or before 1000 bytes
			let mut boundary = 1000;
			while boundary > 0 && !content.is_char_boundary(boundary) {
				boundary -= 1;
			}
			&content[..boundary]
		} else {
			&content
		};

		Ok(self.license_keywords.is_match(search_content))
	}

	fn is_generated_file(&self, content: &str) -> bool {
		for pattern in &self.generated_file_patterns {
			if pattern.is_match(content) {
				return true;
			}
		}
		false
	}

	pub fn add_license(&self, path: &Path) -> Result<bool> {
		let comment_style = match get_comment_style(path) {
			Some(style) => style,
			None => return Ok(false), // Skip files with unknown comment style
		};

		let content = fs::read_to_string(path)?;

		// Skip if already has license or is generated
		if self.has_license(path)? || self.is_generated_file(&content) {
			return Ok(false);
		}

		let license_header = self.format_license_header(&comment_style);
		let new_content = self.insert_license_header(&content, &license_header);

		fs::write(path, new_content)?;
		Ok(true)
	}

	fn format_license_header(&self, comment_style: &CommentStyle) -> String {
		let mut header = String::new();

		// Special handling for JSON files using $license property
		if comment_style.middle == "$license" {
			// Combine all license lines into a single JSON string value
			let license_text = LICENSE_TEMPLATE.lines().collect::<Vec<_>>().join(" - ");
			header.push_str(&format!(
				"  \"{}\": \"{}\",\n",
				comment_style.middle, license_text
			));
			return header;
		}

		// Standard comment formatting for other file types

		// Add opening comment if needed
		if !comment_style.start.is_empty() {
			header.push_str(comment_style.start);
			header.push('\n');
		}

		// Add license content with proper comment prefixes
		for line in LICENSE_TEMPLATE.lines() {
			if line.trim().is_empty() {
				if !comment_style.middle.trim().is_empty() {
					header.push_str(comment_style.middle.trim());
				}
				header.push('\n');
			} else {
				header.push_str(comment_style.middle);
				header.push_str(line);
				header.push('\n');
			}
		}

		// Add closing comment if needed
		if !comment_style.end.is_empty() {
			header.push_str(comment_style.end);
			header.push('\n');
		}

		// Add blank line after header
		header.push('\n');
		header
	}

	fn insert_license_header(&self, content: &str, license_header: &str) -> String {
		// Special handling for JSON files - insert $license property after opening
		// brace
		if license_header.contains("\"$license\":") {
			return self.insert_json_license_property(content, license_header);
		}

		// Handle shebang lines - keep them at the top
		if let Some(shebang_end) = self.find_shebang_end(content) {
			let (shebang, rest) = content.split_at(shebang_end);
			format!(
				"{}{}{}",
				shebang,
				license_header,
				rest.trim_start_matches('\n')
			)
		} else {
			format!("{}{}", license_header, content)
		}
	}

	fn insert_json_license_property(&self, content: &str, license_header: &str) -> String {
		let content = content.trim_start();

		// Find the opening brace
		if let Some(brace_pos) = content.find('{') {
			let (before_brace, after_brace) = content.split_at(brace_pos + 1);
			let after_brace = after_brace.trim_start();

			// Insert the $license property right after the opening brace
			if after_brace.starts_with('}') {
				// Empty JSON object
				format!("{{\n{}}}", license_header.trim_end_matches(','))
			} else {
				// JSON object with existing content
				format!("{}\n{}{}", before_brace, license_header, after_brace)
			}
		} else {
			// Malformed JSON, fallback to prepending
			format!("{}{}", license_header, content)
		}
	}

	fn find_shebang_end(&self, content: &str) -> Option<usize> {
		if content.starts_with("#!") {
			if let Some(newline_pos) = content.find('\n') {
				return Some(newline_pos + 1);
			}
		}
		None
	}
}
