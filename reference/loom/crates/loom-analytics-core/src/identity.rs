// Copyright (c) 2025 Geoffrey Huntley <ghuntley@ghuntley.com>. All rights reserved.
// SPDX-License-Identifier: Proprietary

//! Identity types for linking distinct IDs to persons.
//!
//! A [`PersonIdentity`] represents a link between a `distinct_id` (client identifier)
//! and a [`Person`](crate::Person). Identities can be anonymous (auto-generated UUIDs)
//! or identified (user IDs like emails or usernames).

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::person::PersonId;

/// Unique identifier for a person-identity link.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct PersonIdentityId(pub Uuid);

impl PersonIdentityId {
	pub fn new() -> Self {
		Self(Uuid::new_v4())
	}
}

impl Default for PersonIdentityId {
	fn default() -> Self {
		Self::new()
	}
}

impl std::fmt::Display for PersonIdentityId {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.0)
	}
}

impl std::str::FromStr for PersonIdentityId {
	type Err = uuid::Error;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		Ok(Self(Uuid::parse_str(s)?))
	}
}

/// The type of identity: anonymous or identified.
///
/// - `Anonymous`: Auto-generated client ID (e.g., UUIDv7 from SDK)
/// - `Identified`: User-provided ID (e.g., email, username, database ID)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum IdentityType {
	/// An anonymous identity, typically auto-generated by the SDK.
	Anonymous,
	/// An identified identity, typically a user ID or email.
	Identified,
}

impl IdentityType {
	/// Returns the string representation ("anonymous" or "identified").
	pub fn as_str(&self) -> &'static str {
		match self {
			IdentityType::Anonymous => "anonymous",
			IdentityType::Identified => "identified",
		}
	}
}

impl std::fmt::Display for IdentityType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.as_str())
	}
}

impl std::str::FromStr for IdentityType {
	type Err = String;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		match s {
			"anonymous" => Ok(IdentityType::Anonymous),
			"identified" => Ok(IdentityType::Identified),
			_ => Err(format!("invalid identity type: {}", s)),
		}
	}
}

/// A link between a `distinct_id` and a [`Person`](crate::Person).
///
/// Each identity represents a way to identify a user. A person may have
/// multiple identities (e.g., an anonymous session ID and an email) linked
/// together via identify/alias operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonIdentity {
	/// Unique identifier for this identity record.
	pub id: PersonIdentityId,
	/// The person this identity belongs to.
	pub person_id: PersonId,
	/// The client-side identifier (anonymous UUID or user ID).
	pub distinct_id: String,
	/// Whether this is an anonymous or identified identity.
	pub identity_type: IdentityType,
	/// When this identity was created.
	pub created_at: DateTime<Utc>,
}

impl PersonIdentity {
	/// Creates a new identity linking a distinct ID to a person.
	pub fn new(person_id: PersonId, distinct_id: String, identity_type: IdentityType) -> Self {
		Self {
			id: PersonIdentityId::new(),
			person_id,
			distinct_id,
			identity_type,
			created_at: Utc::now(),
		}
	}

	/// Creates a new anonymous identity.
	pub fn anonymous(person_id: PersonId, distinct_id: String) -> Self {
		Self::new(person_id, distinct_id, IdentityType::Anonymous)
	}

	/// Creates a new identified identity.
	pub fn identified(person_id: PersonId, distinct_id: String) -> Self {
		Self::new(person_id, distinct_id, IdentityType::Identified)
	}

	/// Returns `true` if this is an anonymous identity.
	pub fn is_anonymous(&self) -> bool {
		self.identity_type == IdentityType::Anonymous
	}

	/// Returns `true` if this is an identified identity.
	pub fn is_identified(&self) -> bool {
		self.identity_type == IdentityType::Identified
	}
}

/// Maximum allowed length for distinct IDs.
pub const MAX_DISTINCT_ID_LENGTH: usize = 200;

/// Validates a distinct ID.
///
/// Valid distinct IDs must be non-empty and at most 200 characters.
pub fn validate_distinct_id(distinct_id: &str) -> bool {
	!distinct_id.is_empty() && distinct_id.len() <= MAX_DISTINCT_ID_LENGTH
}

#[cfg(test)]
mod tests {
	use super::*;
	use proptest::prelude::*;

	#[test]
	fn identity_type_roundtrip() {
		assert_eq!(
			"anonymous".parse::<IdentityType>().unwrap(),
			IdentityType::Anonymous
		);
		assert_eq!(
			"identified".parse::<IdentityType>().unwrap(),
			IdentityType::Identified
		);
		assert_eq!(IdentityType::Anonymous.as_str(), "anonymous");
		assert_eq!(IdentityType::Identified.as_str(), "identified");
	}

	#[test]
	fn identity_type_invalid() {
		assert!("invalid".parse::<IdentityType>().is_err());
	}

	#[test]
	fn person_identity_anonymous() {
		let person_id = PersonId::new();
		let identity = PersonIdentity::anonymous(person_id, "anon_123".to_string());
		assert!(identity.is_anonymous());
		assert!(!identity.is_identified());
		assert_eq!(identity.person_id, person_id);
		assert_eq!(identity.distinct_id, "anon_123");
	}

	#[test]
	fn person_identity_identified() {
		let person_id = PersonId::new();
		let identity = PersonIdentity::identified(person_id, "user@example.com".to_string());
		assert!(identity.is_identified());
		assert!(!identity.is_anonymous());
	}

	#[test]
	fn validate_distinct_id_empty() {
		assert!(!validate_distinct_id(""));
	}

	#[test]
	fn validate_distinct_id_too_long() {
		let long = "a".repeat(MAX_DISTINCT_ID_LENGTH + 1);
		assert!(!validate_distinct_id(&long));
	}

	#[test]
	fn validate_distinct_id_max_length() {
		let max = "a".repeat(MAX_DISTINCT_ID_LENGTH);
		assert!(validate_distinct_id(&max));
	}

	proptest! {
		#[test]
		fn person_identity_id_is_unique(_seed: u64) {
			let id1 = PersonIdentityId::new();
			let id2 = PersonIdentityId::new();
			prop_assert_ne!(id1, id2);
		}

		#[test]
		fn person_identity_id_roundtrip(uuid_str in "[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}") {
			if let Ok(id) = uuid_str.parse::<PersonIdentityId>() {
				let s = id.to_string();
				let parsed: PersonIdentityId = s.parse().unwrap();
				prop_assert_eq!(id, parsed);
			}
		}

		#[test]
		fn validate_distinct_id_valid_lengths(len in 1usize..=MAX_DISTINCT_ID_LENGTH) {
			let distinct_id: String = (0..len).map(|_| 'a').collect();
			prop_assert!(validate_distinct_id(&distinct_id));
		}

		#[test]
		fn validate_distinct_id_invalid_lengths(len in (MAX_DISTINCT_ID_LENGTH + 1)..=300usize) {
			let distinct_id: String = (0..len).map(|_| 'a').collect();
			prop_assert!(!validate_distinct_id(&distinct_id));
		}

		#[test]
		fn identity_type_serde_roundtrip(is_anonymous in proptest::bool::ANY) {
			let identity_type = if is_anonymous {
				IdentityType::Anonymous
			} else {
				IdentityType::Identified
			};

			let json = serde_json::to_string(&identity_type).unwrap();
			let parsed: IdentityType = serde_json::from_str(&json).unwrap();
			prop_assert_eq!(identity_type, parsed);
		}
	}
}
