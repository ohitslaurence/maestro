<!--
 Copyright (c) 2025 Geoffrey Huntley <ghuntley@ghuntley.com>. All rights reserved.
 SPDX-License-Identifier: Proprietary
-->

# Auto-Commit System

## Overview

The auto-commit system automatically creates git commits after mutating tool executions
(`edit_file`, `bash`). Commit messages are generated by an LLM (Anthropic Haiku) using the git diff
of changed files. This provides an automatic audit trail of agent-driven changes without polluting
the agent's conversation context.

**Auto-commit is enabled by default** and runs transparently as infrastructure behavior.

**Key principle**: Auto-commit is infrastructure behavior, not an agent tool. It runs as a post-tool
hook in the state machine, invisible to the LLM's reasoning.

**Source files:**

- [`crates/loom-git/`](../crates/loom-git/) - Git operations abstraction
- [`crates/loom-auto-commit/`](../crates/loom-auto-commit/) - Auto-commit orchestration
- [`crates/loom-core/src/state.rs`](../crates/loom-core/src/state.rs) - PostToolsHook state
- [`crates/loom-core/src/agent.rs`](../crates/loom-core/src/agent.rs) - State machine transitions

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              loom-cli                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                     Event Loop / Orchestrator                           ││
│  │  • Receives AgentAction::RunPostToolsHook                               ││
│  │  • Calls AutoCommitService::run()                                       ││
│  │  • Sends AgentEvent::PostToolsHookCompleted                             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    ▼                               ▼
┌─────────────────────────────────┐  ┌─────────────────────────────────┐
│        loom-auto-commit         │  │           loom-core             │
│  ┌───────────────────────────┐  │  │  ┌───────────────────────────┐  │
│  │   AutoCommitService       │  │  │  │   AgentState              │  │
│  │   • run(workspace, tools) │  │  │  │   • PostToolsHook         │  │
│  │   • enabled/disabled      │  │  │  │                           │  │
│  └───────────────────────────┘  │  │  ├───────────────────────────┤  │
│  ┌───────────────────────────┐  │  │  │   AgentEvent              │  │
│  │ CommitMessageGenerator    │  │  │  │   • PostToolsHookCompleted│  │
│  │   • generate(diff) -> msg │  │  │  │                           │  │
│  │   • uses Haiku LLM        │  │  │  ├───────────────────────────┤  │
│  └───────────────────────────┘  │  │  │   AgentAction             │  │
└─────────────────────────────────┘  │  │   • RunPostToolsHook      │  │
                    │                │  └───────────────────────────┘  │
                    ▼                └─────────────────────────────────┘
┌─────────────────────────────────┐
│           loom-git              │
│  ┌───────────────────────────┐  │
│  │   GitClient trait         │  │
│  │   • diff_staged()         │  │
│  │   • stage_all()           │  │
│  │   • commit(msg)           │  │
│  │   • is_repo()             │  │
│  └───────────────────────────┘  │
│  ┌───────────────────────────┐  │
│  │   CommandGitClient        │  │
│  │   (impl via git CLI)      │  │
│  └───────────────────────────┘  │
│  ┌───────────────────────────┐  │
│  │   MockGitClient           │  │
│  │   (for testing)           │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

---

## Crate Structure

### loom-git

**Purpose**: Abstract git operations behind a trait for testability.

**Dependencies**:

- `tokio` (process spawning)
- `tracing` (structured logging)
- `thiserror` (error types)

**Public API**:

```rust
/// Result of a git diff operation.
#[derive(Clone, Debug)]
pub struct GitDiff {
    pub content: String,
    pub files_changed: Vec<String>,
    pub insertions: usize,
    pub deletions: usize,
}

/// Errors from git operations.
#[derive(Debug, thiserror::Error)]
pub enum GitError {
    #[error("not a git repository")]
    NotARepository,
    #[error("git command failed: {0}")]
    CommandFailed(String),
    #[error("git not found in PATH")]
    GitNotFound,
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

/// Trait abstracting git operations.
#[async_trait]
pub trait GitClient: Send + Sync {
    /// Check if the path is inside a git repository.
    async fn is_repository(&self, path: &Path) -> bool;
    
    /// Get the diff of staged changes.
    async fn diff_staged(&self, path: &Path) -> Result<GitDiff, GitError>;
    
    /// Get the diff of unstaged changes (working tree).
    async fn diff_unstaged(&self, path: &Path) -> Result<GitDiff, GitError>;
    
    /// Stage all changes in the repository.
    async fn stage_all(&self, path: &Path) -> Result<(), GitError>;
    
    /// Create a commit with the given message.
    async fn commit(&self, path: &Path, message: &str) -> Result<String, GitError>;
    
    /// Get list of changed files (staged + unstaged).
    async fn changed_files(&self, path: &Path) -> Result<Vec<String>, GitError>;
}

/// Git client implementation using the git CLI.
pub struct CommandGitClient;

/// Mock git client for testing.
pub struct MockGitClient { ... }
```

### loom-auto-commit

**Purpose**: Orchestrate auto-commit behavior using GitClient and LLM.

**Dependencies**:

- `loom-git`
- `loom-core` (LlmClient trait, LlmRequest)
- `tracing`
- `async-trait`

**Public API**:

```rust
/// Configuration for auto-commit behavior.
#[derive(Clone, Debug)]
pub struct AutoCommitConfig {
	/// Whether auto-commit is enabled.
	pub enabled: bool,
	/// Model to use for commit message generation (e.g.,
	/// "claude-3-haiku-20240307").
	pub model: String,
	/// Maximum diff size in bytes before truncation.
	pub max_diff_bytes: usize,
	/// Tools that trigger auto-commit when successful.
	pub trigger_tools: Vec<String>,
}

impl Default for AutoCommitConfig {
	fn default() -> Self {
		Self {
			enabled: true, // Enabled by default
			model: "claude-3-haiku-20240307".to_string(),
			max_diff_bytes: 32 * 1024,
			trigger_tools: vec!["edit_file".to_string(), "bash".to_string()],
		}
	}
}

/// Result of an auto-commit operation.
#[derive(Clone, Debug)]
pub struct AutoCommitResult {
	/// Whether a commit was created.
	pub committed: bool,
	/// The commit hash if committed.
	pub commit_hash: Option<String>,
	/// The generated commit message.
	pub message: Option<String>,
	/// Number of files changed.
	pub files_changed: usize,
	/// Reason if not committed.
	pub skip_reason: Option<String>,
}

/// Service for generating commit messages using an LLM.
pub struct CommitMessageGenerator<L: LlmClient> {
	llm: Arc<L>,
	config: AutoCommitConfig,
}

impl<L: LlmClient> CommitMessageGenerator<L> {
	fn new(llm: Arc<L>, config: AutoCommitConfig) -> Self;

	/// Generate a commit message from a git diff.
	async fn generate(&self, diff: &GitDiff) -> Result<String, AutoCommitError>;
}

/// Main auto-commit service.
pub struct AutoCommitService<G: GitClient, L: LlmClient> {
	git: Arc<G>,
	message_generator: CommitMessageGenerator<L>,
	config: AutoCommitConfig,
}

impl<G: GitClient, L: LlmClient> AutoCommitService<G, L> {
	fn new(git: Arc<G>, llm: Arc<L>, config: AutoCommitConfig) -> Self;

	/// Run auto-commit if conditions are met.
	///
	/// Returns the result of the operation, including whether a commit was made.
	async fn run(
		&self,
		workspace_root: &Path,
		completed_tools: &[CompletedToolInfo],
	) -> AutoCommitResult;

	/// Check if auto-commit should run based on completed tools.
	fn should_run(&self, completed_tools: &[CompletedToolInfo]) -> bool;
}

/// Information about a completed tool execution.
#[derive(Clone, Debug)]
pub struct CompletedToolInfo {
	pub tool_name: String,
	pub succeeded: bool,
}

/// Errors from auto-commit operations.
#[derive(Debug, thiserror::Error)]
pub enum AutoCommitError {
	#[error("git error: {0}")]
	Git(#[from] GitError),
	#[error("LLM error: {0}")]
	Llm(String),
	#[error("auto-commit disabled")]
	Disabled,
}
```

---

## State Machine Integration

### New State: PostToolsHook

Added to `AgentState` in `loom-core/src/state.rs`:

```rust
pub enum AgentState {
	// ... existing states ...
	/// Running post-tool hooks (e.g., auto-commit) after tool execution.
	PostToolsHook {
		conversation: ConversationContext,
		pending_llm_request: LlmRequest,
		completed_tools: Vec<CompletedToolInfo>,
	},
}
```

### New Event: PostToolsHookCompleted

Added to `AgentEvent` in `loom-core/src/state.rs`:

```rust
pub enum AgentEvent {
	// ... existing events ...
	/// Post-tool hooks have completed.
	PostToolsHookCompleted {
		/// Whether any hook performed a significant action (e.g., committed).
		action_taken: bool,
	},
}
```

### New Action: RunPostToolsHook

Added to `AgentAction` in `loom-core/src/agent.rs`:

```rust
pub enum AgentAction {
	// ... existing actions ...
	/// Run post-tool hooks (auto-commit, etc.).
	RunPostToolsHook {
		completed_tools: Vec<CompletedToolInfo>,
	},
}
```

### Transition Table Updates

| Current State    | Event                      | Condition          | New State       | Action             |
| ---------------- | -------------------------- | ------------------ | --------------- | ------------------ |
| `ExecutingTools` | `ToolCompleted` (all done) | has mutating tools | `PostToolsHook` | `RunPostToolsHook` |
| `ExecutingTools` | `ToolCompleted` (all done) | no mutating tools  | `CallingLlm`    | `SendLlmRequest`   |
| `PostToolsHook`  | `PostToolsHookCompleted`   | —                  | `CallingLlm`    | `SendLlmRequest`   |
| `PostToolsHook`  | `ShutdownRequested`        | —                  | `ShuttingDown`  | `Shutdown`         |

### Updated State Diagram

```mermaid
stateDiagram-v2
    [*] --> WaitingForUserInput : Agent::new()
    
    WaitingForUserInput --> CallingLlm : UserInput
    
    CallingLlm --> CallingLlm : TextDelta / ToolCallDelta
    CallingLlm --> ProcessingLlmResponse : Completed
    CallingLlm --> Error : Error (retries < max)
    CallingLlm --> WaitingForUserInput : Error (retries >= max)
    
    ProcessingLlmResponse --> ExecutingTools : has tool calls
    ProcessingLlmResponse --> WaitingForUserInput : no tool calls
    
    ExecutingTools --> ExecutingTools : ToolCompleted (some pending)
    ExecutingTools --> PostToolsHook : ToolCompleted (all done, has mutating)
    ExecutingTools --> CallingLlm : ToolCompleted (all done, no mutating)
    
    PostToolsHook --> CallingLlm : PostToolsHookCompleted
    
    Error --> CallingLlm : RetryTimeoutFired
    
    WaitingForUserInput --> ShuttingDown : ShutdownRequested
    CallingLlm --> ShuttingDown : ShutdownRequested
    ProcessingLlmResponse --> ShuttingDown : ShutdownRequested
    ExecutingTools --> ShuttingDown : ShutdownRequested
    PostToolsHook --> ShuttingDown : ShutdownRequested
    Error --> ShuttingDown : ShutdownRequested
    
    ShuttingDown --> [*]
```

---

## Commit Message Generation

### Prompt Template

The commit message generator uses a carefully crafted prompt to produce conventional commit
messages:

**System Prompt**:

```
You are an expert software engineer generating git commit messages.

Rules:
1. Use conventional commit format: <type>(<scope>): <description>
2. Types: feat, fix, refactor, docs, style, test, chore
3. Keep the first line under 72 characters
4. Be specific about what changed, not why
5. Use imperative mood ("add" not "added")
6. If multiple unrelated changes, summarize the primary one

Examples:
- feat(auth): add JWT token validation
- fix(api): handle null response from upstream
- refactor(tools): extract path validation helper
- chore(deps): update tokio to 1.35
```

**User Prompt**:

```
Generate a commit message for these changes:

<diff>
{truncated_diff}
</diff>

{truncation_notice if applicable}
```

### Truncation Strategy

When diffs exceed `max_diff_bytes`:

1. Prioritize showing file names and stats (`--stat` output)
2. Include as much actual diff as fits
3. Append truncation notice: `\n\n[TRUNCATED: {total_bytes} bytes, showing first {shown_bytes}]`

---

## CLI Integration

### Configuration

Auto-commit is **enabled by default**. It can be disabled via environment variable:

```bash
# Disable auto-commit
LOOM_AUTO_COMMIT_DISABLE=true loom

# Or using other truthy values
LOOM_AUTO_COMMIT_DISABLE=1 loom
LOOM_AUTO_COMMIT_DISABLE=yes loom
```

The model used for commit message generation is fixed to `claude-3-haiku-20240307` and cannot be
changed by the user.

### Orchestration

In the REPL event loop (`loom-cli`):

```rust
match action {
    AgentAction::RunPostToolsHook { completed_tools } => {
        let result = auto_commit_service
            .run(&workspace_root, &completed_tools)
            .await;
        
        tracing::info!(
            committed = result.committed,
            files_changed = result.files_changed,
            commit_hash = ?result.commit_hash,
            skip_reason = ?result.skip_reason,
            "auto-commit completed"
        );
        
        agent.handle_event(AgentEvent::PostToolsHookCompleted {
            action_taken: result.committed,
        })?;
    }
    // ... other actions ...
}
```

---

## Error Handling

### Fail-Open Strategy

Auto-commit failures must **never** block the agent. All errors result in:

1. Structured log with full error details
2. `AutoCommitResult { committed: false, skip_reason: Some(...) }`
3. `PostToolsHookCompleted { action_taken: false }` event sent to agent
4. Agent continues normally to `CallingLlm`

### Error Categories

| Error                | Handling             | Log Level |
| -------------------- | -------------------- | --------- |
| Not a git repo       | Skip silently        | `debug!`  |
| Git not found        | Skip with notice     | `info!`   |
| No changes to commit | Skip silently        | `debug!`  |
| LLM failure          | Use fallback message | `warn!`   |
| Git commit failure   | Log and skip         | `error!`  |

### Fallback Commit Message

If LLM fails to generate a message:

```
chore: auto-commit from loom

[Auto-generated fallback: LLM unavailable]
```

---

## Security Considerations

### Workspace Boundary

Auto-commit only operates within `workspace_root`:

- `git add` is scoped to workspace
- Rejects operations if workspace is not under a git repo root
- Logs warning if workspace is a subdirectory of repo

### Sensitive Data in Diffs

The diff sent to the LLM may contain sensitive data. Mitigations:

1. Use `loom-redact` system (if implemented) to filter secrets from diff
2. Log warning if diff contains potential secrets (pattern matching)
3. Document that diffs are sent to LLM in user-facing docs
4. Consider future `--auto-commit-local` mode using local model

### Git Hooks

Auto-commit respects git hooks:

- Pre-commit hooks run normally
- If hooks fail, commit is skipped (logged as error)
- Consider `--no-verify` flag for future if needed

---

## Testing Strategy

### Property-Based Tests

**loom-git**:

```rust
proptest! {
		/// GitDiff parsing always produces valid UTF-8 content.
		#[test]
		fn diff_content_is_valid_utf8(content in ".*") {
				// ...
		}

		/// Commit message is preserved exactly in git log.
		#[test]
		fn commit_message_roundtrips(msg in "[^\x00]{1,1000}") {
				// ...
		}
}
```

**loom-auto-commit**:

```rust
proptest! {
		/// Auto-commit never blocks when disabled.
		#[test]
		fn disabled_returns_immediately(tools in vec(completed_tool_info(), 0..10)) {
				// ...
		}

		/// Truncation always produces valid prompt under limit.
		#[test]
		fn truncation_respects_limit(diff_size in 0usize..100_000) {
				// ...
		}
}
```

**loom-core**:

```rust
proptest! {
		/// PostToolsHook always transitions to CallingLlm on completion.
		#[test]
		fn post_tools_hook_always_completes(_dummy in 0u8..1) {
				// ...
		}

		/// Shutdown always succeeds from PostToolsHook.
		#[test]
		fn shutdown_from_post_tools_hook(_dummy in 0u8..1) {
				// ...
		}
}
```

### Integration Tests

- Test full flow: edit_file → auto-commit → verify git log
- Test with mock git client returning various error conditions
- Test with mock LLM client returning various responses

---

## Future Extensions

### Additional Post-Tool Hooks

The `PostToolsHook` state is designed to be extensible:

```rust
pub struct PostToolsHookConfig {
	pub auto_commit: AutoCommitConfig,
	pub auto_format: Option<AutoFormatConfig>, // Future: run formatters
	pub auto_lint: Option<AutoLintConfig>,     // Future: run linters
}
```

### Commit Policies

Future configuration options:

- `commit_per_tool`: One commit per tool vs. batched
- `commit_per_turn`: One commit per user turn
- `interactive`: Ask user before committing
- `squash_on_success`: Squash all commits at conversation end

### Server-Side Commit Message Service

For multi-client deployments:

- Add `/proxy/commit-message` endpoint to `loom-server`
- Encapsulate model selection and prompt engineering
- Enable A/B testing of prompt strategies

---

## Dependency Graph

```
loom-cli
    ├── loom-auto-commit
    │   ├── loom-git
    │   └── loom-core (LlmClient trait only)
    ├── loom-core
    └── loom-tools
```

`loom-git` and `loom-auto-commit` are leaf crates with minimal dependencies, ensuring they don't
bloat the core dependency tree.
